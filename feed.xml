<feed xmlns="http://www.w3.org/2005/Atom"> <generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="https://flying-polarbear.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://flying-polarbear.github.io/" rel="alternate" type="text/html" /> <updated>2019-09-25T15:17:50+08:00</updated> <id>https://flying-polarbear.github.io//feed.xml</id> <entry><title>leetcode Valid Parentheses</title><link href="https://flying-polarbear.github.io//posts/leetcode-Valid-Parentheses/" rel="alternate" type="text/html" title="leetcode Valid Parentheses" /><published>2019-09-25T15:13:00+08:00</published> <updated>2019-09-25T15:17:50+08:00</updated> <id>https://flying-polarbear.github.io//posts/leetcode-Valid-Parentheses/</id> <content src="https://flying-polarbear.github.io//posts/leetcode-Valid-Parentheses/" /> <author> <name>搞生信的变态</name> </author> <category term="Tech" /> <category term="leetcode" /> <summary>leetcode非常经典的算法题，Valid Parentheses,大意就是验证括号是否是符合匹配配对规则的，例如()[]是相互配对的,但是([)]就不是相互配对的了。 此题已经将范围缩小到字符串只包含大中小三种括号的字符了，所以只需要去考虑如何计算是否匹配了。 方案 这里资源最小，速度最快的方案是用到了所谓的栈技术。 我们假设”()[]{}”这种情况，可以知道这是符合配对规则的。首先第...</summary> </entry> <entry><title>谈一谈编程语言对行为的影响</title><link href="https://flying-polarbear.github.io//posts/leetcode_2/" rel="alternate" type="text/html" title="谈一谈编程语言对行为的影响" /><published>2019-09-24T14:12:00+08:00</published> <updated>2019-09-25T15:17:50+08:00</updated> <id>https://flying-polarbear.github.io//posts/leetcode_2/</id> <content src="https://flying-polarbear.github.io//posts/leetcode_2/" /> <author> <name>搞生信的变态</name> </author> <category term="Tech" /> <category term="leetcode" /> <summary>本博到现在为止也没正经的说过和讨论编程语言的对比之类的，因为这一方面可能会引来各个派系的圣战，另一方面自觉才疏学浅，也没有这个资历说三道四，但是有时候也会有点小想法。比如我下面要说的： 本文先由leetcode的一道easy类别的题引出count and say。 大意就是给定以个1&lt;=n&lt;=30，要你解出一个字符串，规则就是去数上一个字符串的规律，比如： 1. 1 2...</summary> </entry> <entry><title>一个easy题目的长篇大论</title><link href="https://flying-polarbear.github.io//posts/leetcode_1/" rel="alternate" type="text/html" title="一个easy题目的长篇大论" /><published>2019-09-20T19:45:00+08:00</published> <updated>2019-09-25T15:17:50+08:00</updated> <id>https://flying-polarbear.github.io//posts/leetcode_1/</id> <content src="https://flying-polarbear.github.io//posts/leetcode_1/" /> <author> <name>搞生信的变态</name> </author> <category term="Tech" /> <category term="leetcode" /> <summary>上篇提到了codewars的一道算法题，这次是著名算法网站leetcode的介绍，这两个网站区别就以后在说了。因为以前也在leetcode玩过，但是没系统的，没持久的进行过，真的只是玩玩，现在还是希望自己能够熟悉算法的一些内容，虽然不是算法科班出身，但是掌握常用算法以及思路还是绝对必要的。 由于是leetcode开篇之作，所以也拿网站第一道的easy类别题来实例，题目地址two sum 任...</summary> </entry> <entry><title>一个有趣的算法题(1)</title><link href="https://flying-polarbear.github.io//posts/codewars_1/" rel="alternate" type="text/html" title="一个有趣的算法题(1)" /><published>2019-09-18T15:07:00+08:00</published> <updated>2019-09-25T15:17:50+08:00</updated> <id>https://flying-polarbear.github.io//posts/codewars_1/</id> <content src="https://flying-polarbear.github.io//posts/codewars_1/" /> <author> <name>搞生信的变态</name> </author> <category term="Tech" /> <category term="ruby" /> <summary>编程果然是一项需要学到老的技能，放下手1个礼拜不码代码就感觉有种陌生感了。 所以没事刷刷存在感还是很有必要的，防止中年痴呆！ 好了，废话不多说，第一次带来的一道题很有去，来自于codewars，详情请看页面描述。 题目大概意思就是149本身是一个素数，然后由149构成的3个数字：1，4，9可以排列成419，491，941三个素数。小于1000的数字中，有3个素数可以由自身排列成3个其他的...</summary> </entry> <entry><title>COSMIC进阶（一）</title><link href="https://flying-polarbear.github.io//posts/COSMIC%E8%BF%9B%E9%98%B6-%E4%B8%80/" rel="alternate" type="text/html" title="COSMIC进阶（一）" /><published>2019-09-05T15:17:00+08:00</published> <updated>2019-09-25T15:17:50+08:00</updated> <id>https://flying-polarbear.github.io//posts/COSMIC%E8%BF%9B%E9%98%B6-%E4%B8%80/</id> <content src="https://flying-polarbear.github.io//posts/COSMIC%E8%BF%9B%E9%98%B6-%E4%B8%80/" /> <author> <name>搞生信的变态</name> </author> <category term="Tech" /> <category term="cosmic" /> <summary>COSMIC进阶 前言：虽然标题有（一），但是并不一定会有（二）！！！因为写东西还是比较费时间的，可能碰见什么感兴趣的，觉得别人没碰过的，又觉得对其他有帮助的才会花时间写吧。 首先我们以FAT1基因为例，打开cosmic网站的FAT1页面FAT1_COSMIC，然后在页面中的Tissue Distribution为例，可以看到列出了FAT1基因在各个不同癌症中的突变频次和频率，假设我们对...</summary> </entry> </feed>
