<feed xmlns="http://www.w3.org/2005/Atom"> <generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="https://flying-polarbear.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://flying-polarbear.github.io/" rel="alternate" type="text/html" /> <updated>2019-09-27T10:39:35+08:00</updated> <id>https://flying-polarbear.github.io//feed.xml</id> <entry><title>VEP REST服务简单介绍</title><link href="https://flying-polarbear.github.io//posts/vep-rest/" rel="alternate" type="text/html" title="VEP REST服务简单介绍" /><published>2019-09-27T10:32:00+08:00</published> <updated>2019-09-27T10:39:35+08:00</updated> <id>https://flying-polarbear.github.io//posts/vep-rest/</id> <content src="https://flying-polarbear.github.io//posts/vep-rest/" /> <author> <name>搞生信的变态</name> </author> <category term="Tech" /> <category term="vep" /> <summary>一个很小的需求，比如手里有基因的location信息，1:3342113-3342291，想知道这段区域有哪些基因，转录本或者其他信息该怎么做？ 当然可以打开网页去各大数据库搜索，或者调用注释软件，但是去网页搜索效率低，像我这种电脑卡的人每多开一个网页就是多一份负担，而调用注释软件又显得太大才小用了，操作也比较麻烦，想得到个性化信息也非常不好操作。 好了，这里介绍来自vep的一个REST服务...</summary> </entry> <entry><title>leetcode Valid Parentheses</title><link href="https://flying-polarbear.github.io//posts/leetcode-Valid-Parentheses/" rel="alternate" type="text/html" title="leetcode Valid Parentheses" /><published>2019-09-25T15:13:00+08:00</published> <updated>2019-09-27T10:39:35+08:00</updated> <id>https://flying-polarbear.github.io//posts/leetcode-Valid-Parentheses/</id> <content src="https://flying-polarbear.github.io//posts/leetcode-Valid-Parentheses/" /> <author> <name>搞生信的变态</name> </author> <category term="Tech" /> <category term="leetcode" /> <summary>leetcode非常经典的算法题，Valid Parentheses,大意就是验证括号是否是符合匹配配对规则的，例如()[]是相互配对的,但是([)]就不是相互配对的了。 此题已经将范围缩小到字符串只包含大中小三种括号的字符了，所以只需要去考虑如何计算是否匹配了。 方案 这里资源最小，速度最快的方案是用到了所谓的栈技术。 我们假设”()[]{}”这种情况，可以知道这是符合配对规则的。首先第...</summary> </entry> <entry><title>谈一谈编程语言对行为的影响</title><link href="https://flying-polarbear.github.io//posts/leetcode_2/" rel="alternate" type="text/html" title="谈一谈编程语言对行为的影响" /><published>2019-09-24T14:12:00+08:00</published> <updated>2019-09-27T10:39:35+08:00</updated> <id>https://flying-polarbear.github.io//posts/leetcode_2/</id> <content src="https://flying-polarbear.github.io//posts/leetcode_2/" /> <author> <name>搞生信的变态</name> </author> <category term="Tech" /> <category term="leetcode" /> <summary>本博到现在为止也没正经的说过和讨论编程语言的对比之类的，因为这一方面可能会引来各个派系的圣战，另一方面自觉才疏学浅，也没有这个资历说三道四，但是有时候也会有点小想法。比如我下面要说的： 本文先由leetcode的一道easy类别的题引出count and say。 大意就是给定以个1&lt;=n&lt;=30，要你解出一个字符串，规则就是去数上一个字符串的规律，比如： 1. 1 2...</summary> </entry> <entry><title>一个easy题目的长篇大论</title><link href="https://flying-polarbear.github.io//posts/leetcode_1/" rel="alternate" type="text/html" title="一个easy题目的长篇大论" /><published>2019-09-20T19:45:00+08:00</published> <updated>2019-09-27T10:39:35+08:00</updated> <id>https://flying-polarbear.github.io//posts/leetcode_1/</id> <content src="https://flying-polarbear.github.io//posts/leetcode_1/" /> <author> <name>搞生信的变态</name> </author> <category term="Tech" /> <category term="leetcode" /> <summary>上篇提到了codewars的一道算法题，这次是著名算法网站leetcode的介绍，这两个网站区别就以后在说了。因为以前也在leetcode玩过，但是没系统的，没持久的进行过，真的只是玩玩，现在还是希望自己能够熟悉算法的一些内容，虽然不是算法科班出身，但是掌握常用算法以及思路还是绝对必要的。 由于是leetcode开篇之作，所以也拿网站第一道的easy类别题来实例，题目地址two sum 任...</summary> </entry> <entry><title>一个有趣的算法题(1)</title><link href="https://flying-polarbear.github.io//posts/codewars_1/" rel="alternate" type="text/html" title="一个有趣的算法题(1)" /><published>2019-09-18T15:07:00+08:00</published> <updated>2019-09-27T10:39:35+08:00</updated> <id>https://flying-polarbear.github.io//posts/codewars_1/</id> <content src="https://flying-polarbear.github.io//posts/codewars_1/" /> <author> <name>搞生信的变态</name> </author> <category term="Tech" /> <category term="ruby" /> <summary>编程果然是一项需要学到老的技能，放下手1个礼拜不码代码就感觉有种陌生感了。 所以没事刷刷存在感还是很有必要的，防止中年痴呆！ 好了，废话不多说，第一次带来的一道题很有去，来自于codewars，详情请看页面描述。 题目大概意思就是149本身是一个素数，然后由149构成的3个数字：1，4，9可以排列成419，491，941三个素数。小于1000的数字中，有3个素数可以由自身排列成3个其他的...</summary> </entry> </feed>
